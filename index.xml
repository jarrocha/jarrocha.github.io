<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Innercoder.dev</title>
    <link>https://jarrocha.github.io/</link>
    <description>Recent content on Innercoder.dev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Nov 2021 17:09:43 -0500</lastBuildDate>
    
	<atom:link href="https://jarrocha.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Quadrotor Autopilot Design Part 1: Dynamics</title>
      <link>https://jarrocha.github.io/post/quadrotor_dynamics/</link>
      <pubDate>Fri, 12 Nov 2021 17:09:43 -0500</pubDate>
      
      <guid>https://jarrocha.github.io/post/quadrotor_dynamics/</guid>
      <description>Intro  In this post I will show the derivations of the equations to describe the behavior of a quadrotor. This is will be a 3-5 part series that will consist on dynamics, system simulation, control design with PID, control design with Optimal Control, EKF, and finally to see it on an actual quadrotor. This is based on what I learned from the Udacity Nanodegree course on quadrotor autopilot design with some further study on my own.</description>
    </item>
    
    <item>
      <title>Road Lane Detection with OpenCV and Python</title>
      <link>https://jarrocha.github.io/post/lane_finding/</link>
      <pubDate>Tue, 14 Sep 2021 06:45:31 -0500</pubDate>
      
      <guid>https://jarrocha.github.io/post/lane_finding/</guid>
      <description>Introduction  This was my first attempt at working at this project based on the Udacity course. I found it an amazing experience to learn about this because once you get through all the math and see the results, you get a very good feeling of accomplishment, understanding, and humility on the problem to be solved.
Development  The code below is done twice, once for building single images and then the refactoring of the code to deal with videos.</description>
    </item>
    
    <item>
      <title>Dynamic System Integration and Plotting with C&#43;&#43;</title>
      <link>https://jarrocha.github.io/post/euler1/</link>
      <pubDate>Sun, 20 Jun 2021 11:07:09 -0500</pubDate>
      
      <guid>https://jarrocha.github.io/post/euler1/</guid>
      <description>Intro  This is a quick demonstration on how to solve a state representation with the Euler method, collecting the values, and then plotting them.
I didn&amp;rsquo;t found a solution that wasn&amp;rsquo;t easy out there so I thought on getting the easy to integrate plotting library and a good math-algebra library to work with.
This is based on some work I did before with simulation. There&amp;rsquo;s some potential on expanding this, which I&amp;rsquo;ll do once I have more time.</description>
    </item>
    
    <item>
      <title>STM32 SPI Driver Testing with Logic Analyzer</title>
      <link>https://jarrocha.github.io/post/spi_driver_test/</link>
      <pubDate>Wed, 19 May 2021 11:24:35 -0500</pubDate>
      
      <guid>https://jarrocha.github.io/post/spi_driver_test/</guid>
      <description>Intro This is a short post on how to use a Logic Analyzer to test an SPI driver implementation when not having another device to test with.
I recently bought a Saleae Logic Analyzer and it comes with a very convenient protocol analyzer tool to test SPI, I2C, CAN and other protocols. Here is the web guide.
I wanted to test this for myself so I updated and uploaded an old SPI driver I wrote for STM32F446.</description>
    </item>
    
    <item>
      <title>Setting up ARM MbedOS cli on Linux</title>
      <link>https://jarrocha.github.io/post/setup-mbed-cli-on-linux/</link>
      <pubDate>Mon, 04 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://jarrocha.github.io/post/setup-mbed-cli-on-linux/</guid>
      <description>Intro  This tutorial comes from the fact that there are several steps where errors can come up.
Steps  1. Download the latest toolchain. It can be untar and installed where its more convinient: https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads
2. Install mbed-cli with python. This steps are well made from the website. Make your to be using Python3. https://os.mbed.com/docs/mbed-os/v6.3/build-tools/install-and-set-up.html
3. Configure GCC_ARM_PATH and ARM_PATH
$ mbed config -G ARM_PATH &amp;#34;&amp;lt;path to ARM bin\&amp;gt;&amp;#34; $ mbed config -G GCC_ARM_PATH &amp;#34;&amp;lt;path to ARM bin\&amp;gt;&amp;#34; Test output:</description>
    </item>
    
    <item>
      <title>Setting up Zephyr on Linux</title>
      <link>https://jarrocha.github.io/post/setup-zephyr-on-linux/</link>
      <pubDate>Sat, 02 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jarrocha.github.io/post/setup-zephyr-on-linux/</guid>
      <description>Intro  Zephyr is a little easier to setup compared to Mbed OS to setup. This was done on Debian 9 with a FRDM-K64F.
Steps  1. Install the necessary requirements
sudo apt-get install --no-install-recommends git cmake ninja-build gperf \  ccache dfu-util device-tree-compiler wget \  python3-pip python3-setuptools python3-wheel xz-utils file make gcc 2. Download and Install SDK
wget https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.10.0/zephyr-sdk-0.10.0-setup.run cd &amp;lt;sdk download directory&amp;gt; sh zephyr-sdk-0.10.0-setup.run export ZEPHYR_TOOLCHAIN_VARIANT=zephyr export ZEPHYR_GCC_VARIANT=zephyr export ZEPHYR_SDK_INSTALL_DIR=&amp;lt;sdk installation directory&amp;gt; 3.</description>
    </item>
    
    <item>
      <title>Linux Kernel Modules: Character Devices</title>
      <link>https://jarrocha.github.io/post/2018-11-18-char-driver/</link>
      <pubDate>Mon, 12 Nov 2018 14:00:17 -0700</pubDate>
      
      <guid>https://jarrocha.github.io/post/2018-11-18-char-driver/</guid>
      <description>Intro  This post will be part of a series where device drivers will be presented and quickly analized for people that need a quick reference of how to make device drivers on an updated kernel. The driver presented here was tested on a 3.2 and 3.16 Linux Kernel. I will make a driver with more features and test it on a newer kernel next time.
The complete code is in its github repository.</description>
    </item>
    
    <item>
      <title>Coding Your Own Network Sniffer</title>
      <link>https://jarrocha.github.io/post/2018-11-18-network-sniffer/</link>
      <pubDate>Sat, 11 Mar 2017 16:47:01 -0700</pubDate>
      
      <guid>https://jarrocha.github.io/post/2018-11-18-network-sniffer/</guid>
      <description>&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;This a small project that came to mind after reading some reference
material while stuyding HTTP. It basically consists of using raw sockets to
make the kernel handle L2 data/frames to the user application. From there
anything is possible, a ping server, a traceroute appication, IP spoofing,
man-in-the-middle attacks, the sky is the limits.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Capturing Websites With Sockets and HTTP</title>
      <link>https://jarrocha.github.io/post/2018-11-18-sockets-http/</link>
      <pubDate>Fri, 02 Sep 2016 11:57:56 -0700</pubDate>
      
      <guid>https://jarrocha.github.io/post/2018-11-18-sockets-http/</guid>
      <description>&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;This post shows a program that captures web pagesâ€™s index.html with sockets.
To do this, it creates a TCP client socket, connects to a web server and takes
all the data to stdout. The input supports IPv4, IPv6, and hostname resolution.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Implementing a Prethreaded Web Server</title>
      <link>https://jarrocha.github.io/post/2018-11-18-pthreaded-server/</link>
      <pubDate>Wed, 13 Jul 2016 16:53:42 -0700</pubDate>
      
      <guid>https://jarrocha.github.io/post/2018-11-18-pthreaded-server/</guid>
      <description>Intro In this post I will analyze an implementation of a prethreaded TCP server that leverages the HTTP protocol. This is a personal ongoing project that will continue its development and I found it to be at a good place to start sharing what I have done so far. The whole purpose of this is to later on built a tool to test its performance and how to break it with malformed packets.</description>
    </item>
    
    <item>
      <title>Code Performance Analysis With Assembly &amp; C: Part 2</title>
      <link>https://jarrocha.github.io/post/2018-11-18-performance-analysis-ii/</link>
      <pubDate>Wed, 18 May 2016 16:43:48 -0700</pubDate>
      
      <guid>https://jarrocha.github.io/post/2018-11-18-performance-analysis-ii/</guid>
      <description>Introduction  In this second part, the optimization code will be shown. Specifically O1, O2, and O3. We are going to be able to see, what performance decisions the gcc compiler makes; for example, we are going to check if the compilers takes the function that calculates the string length calls out of the loop.
O1 Optimization Here is the command to created the assembly code:
gcc -fno-asynchronous-unwind-tables -S -O1 -o psum1_O1.</description>
    </item>
    
    <item>
      <title>TCP Sockets Server</title>
      <link>https://jarrocha.github.io/post/tcp-server/</link>
      <pubDate>Wed, 18 May 2016 10:47:50 -0400</pubDate>
      
      <guid>https://jarrocha.github.io/post/tcp-server/</guid>
      <description>Intro  This post serves as a explanation of the basics of a TCP socket server, which serves as the base to a future post explaining the basics of a web server.
Note: the complete code of an older version is fully posted in the end. Check my github repo for an updated version. Link.
There are good tutorials out there that explain each of the functions of the sockets POSIX API in detail so this post will serve mostly to understand the overall basics.</description>
    </item>
    
    <item>
      <title>Installing and Configuring OpenvSwitch With QEMU-KVM</title>
      <link>https://jarrocha.github.io/post/2018-11-18-ovs-kvm/</link>
      <pubDate>Mon, 18 Apr 2016 16:25:31 -0700</pubDate>
      
      <guid>https://jarrocha.github.io/post/2018-11-18-ovs-kvm/</guid>
      <description>Introduction  The maturity reached by Software Defined Networking (SDN) in the lastest years is a very important one. We are at a point where we could see this architecture /framework become a standard. And what makes it so amazing is its fundamental idea of openness, just like Linux did it around 20 years ago. OpenvSwitch (OVS) is a tool used to create virtual bridges which can then connect virtual or physical hosts.</description>
    </item>
    
    <item>
      <title>Automating Quagga With QEMU-KVM</title>
      <link>https://jarrocha.github.io/post/2018-11-18-quagga-kvm-i/</link>
      <pubDate>Wed, 23 Mar 2016 16:06:40 -0700</pubDate>
      
      <guid>https://jarrocha.github.io/post/2018-11-18-quagga-kvm-i/</guid>
      <description>Introduction  Some days ago I needed a proof of concept for some routing configuration using Linux that was stuck in my head for days already. So I needed a way to bring up some Linux boxes to quickly to check this. The ONL website proved very useful, but I needed to use CentOS. So I came up with a script based on the mentioned tutorial that brings up QEMU-KVM images with Quagga already installed and configured.</description>
    </item>
    
    <item>
      <title>Code Performance Analysis With Assembly &amp; C: Part 1</title>
      <link>https://jarrocha.github.io/post/2018-11-18-performance-analysis-i/</link>
      <pubDate>Fri, 19 Feb 2016 12:38:59 -0700</pubDate>
      
      <guid>https://jarrocha.github.io/post/2018-11-18-performance-analysis-i/</guid>
      <description>These blog series belong to some old notes that I have and thought that could be useful to redo. It is always good to refresh material and what a better way than to write about it.
These series will consists of presenting an algorithm in C that will iteratively be re-coded for better performance. Assembly code will be shown so as to show what&amp;rsquo;s going on at the instruction level, gprof, valgrind, and perf will be used to assess quantitavely our coding efforts.</description>
    </item>
    
    <item>
      <title>Programming a Linux Shell Terminal</title>
      <link>https://jarrocha.github.io/post/2018-11-18-shell-prog-basics/</link>
      <pubDate>Tue, 12 Jan 2016 10:30:20 -0700</pubDate>
      
      <guid>https://jarrocha.github.io/post/2018-11-18-shell-prog-basics/</guid>
      <description>Introduction A shell is an interactive program that in its core forks for new processes and wait for their termination. In other words, we present a prompt, the user enters the commands, we parse the input , and execute it. Good error and signal handling is needed, as well as the return values of the different system calls that we will use. The man pages come real handy for this since we have a very good reference just a terminal screen away.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jarrocha.github.io/search/placeholder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jarrocha.github.io/search/placeholder/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://jarrocha.github.io/top/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jarrocha.github.io/top/about/</guid>
      <description>About My name is Jaime Arrocha, I am an expericenced macOS and Linux system/kernel developer with interest in embedded systems, IoT, RTOS, computer networking, and cloud computing. I created this website with the intent of both learning and giving back to the community. I hope that the information you find here is helpful. I will try my best to keep the website alive with interesting posts and topics, while also improving on my writing skills.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jarrocha.github.io/top/courses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jarrocha.github.io/top/courses/</guid>
      <description>Courses on Embedded Systems, Robotics, and Controls  Here are some courses that I have taken and found to be really good. They are either free or low cost. They all vary in skills from software development, embedded systems, and control systems.
Space Dynamics and Control Coursera Space Dynamics and Control Autonomous Navigation for Flying Robots Coursera Autonomous Navigation for Flying Robots
Robotics Specialization Coursera Robotics Specialization
Modern Robotics Specialization Coursera Modern Robotics Specialization</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jarrocha.github.io/top/upcoming/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jarrocha.github.io/top/upcoming/</guid>
      <description>Upcoming Topics  I have always considered that teaching is a good learning tool. So I plan to revamped the site with a few good topics involving some good theory mix with actual code results on devices.
Topics will include:   Kernel Drivers on Raspberry Pi and BeagleBone Black  Involved Blocked devices and I2C communication with peripherals. USB drivers   RTOS  Timing sequences differences between Linux-RT and Linux with SCHED_FIFO + affinity settings.</description>
    </item>
    
  </channel>
</rss>