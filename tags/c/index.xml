<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C on Innercoder.dev</title>
    <link>https://jarrocha.github.io/tags/c/</link>
    <description>Recent content in C on Innercoder.dev</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 20 Jun 2021 11:07:09 -0500</lastBuildDate>
    
	<atom:link href="https://jarrocha.github.io/tags/c/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Dynamic System Integration and Plotting with C&#43;&#43;</title>
      <link>https://jarrocha.github.io/post/euler1/</link>
      <pubDate>Sun, 20 Jun 2021 11:07:09 -0500</pubDate>
      
      <guid>https://jarrocha.github.io/post/euler1/</guid>
      <description>Intro  This is a quick demonstration on how to solve a state representation with the Euler method, collecting the values, and then plotting them.
I didn&amp;rsquo;t found a solution that wasn&amp;rsquo;t easy out there so I thought on getting the easy to integrate plotting library and a good math-algebra library to work with.
This is based on some work I did before with simulation. There&amp;rsquo;s some potential on expanding this, which I&amp;rsquo;ll do once I have more time.</description>
    </item>
    
    <item>
      <title>STM32 SPI Driver Testing with Logic Analyzer</title>
      <link>https://jarrocha.github.io/post/spi_driver_test/</link>
      <pubDate>Wed, 19 May 2021 11:24:35 -0500</pubDate>
      
      <guid>https://jarrocha.github.io/post/spi_driver_test/</guid>
      <description>Intro This is a short post on how to use a Logic Analyzer to test an SPI driver implementation when not having another device to test with.
I recently bought a Saleae Logic Analyzer and it comes with a very convenient protocol analyzer tool to test SPI, I2C, CAN and other protocols. Here is the web guide.
I wanted to test this for myself so I updated and uploaded an old SPI driver I wrote for STM32F446.</description>
    </item>
    
    <item>
      <title>Linux Kernel Modules: Character Devices</title>
      <link>https://jarrocha.github.io/post/2018-11-18-char-driver/</link>
      <pubDate>Mon, 12 Nov 2018 14:00:17 -0700</pubDate>
      
      <guid>https://jarrocha.github.io/post/2018-11-18-char-driver/</guid>
      <description>Intro  This post will be part of a series where device drivers will be presented and quickly analized for people that need a quick reference of how to make device drivers on an updated kernel. The driver presented here was tested on a 3.2 and 3.16 Linux Kernel. I will make a driver with more features and test it on a newer kernel next time.
The complete code is in its github repository.</description>
    </item>
    
    <item>
      <title>Implementing a Prethreaded Web Server</title>
      <link>https://jarrocha.github.io/post/2018-11-18-pthreaded-server/</link>
      <pubDate>Wed, 13 Jul 2016 16:53:42 -0700</pubDate>
      
      <guid>https://jarrocha.github.io/post/2018-11-18-pthreaded-server/</guid>
      <description>Intro In this post I will analyze an implementation of a prethreaded TCP server that leverages the HTTP protocol. This is a personal ongoing project that will continue its development and I found it to be at a good place to start sharing what I have done so far. The whole purpose of this is to later on built a tool to test its performance and how to break it with malformed packets.</description>
    </item>
    
    <item>
      <title>Code Performance Analysis With Assembly &amp; C: Part 2</title>
      <link>https://jarrocha.github.io/post/2018-11-18-performance-analysis-ii/</link>
      <pubDate>Wed, 18 May 2016 16:43:48 -0700</pubDate>
      
      <guid>https://jarrocha.github.io/post/2018-11-18-performance-analysis-ii/</guid>
      <description>Introduction  In this second part, the optimization code will be shown. Specifically O1, O2, and O3. We are going to be able to see, what performance decisions the gcc compiler makes; for example, we are going to check if the compilers takes the function that calculates the string length calls out of the loop.
O1 Optimization Here is the command to created the assembly code:
gcc -fno-asynchronous-unwind-tables -S -O1 -o psum1_O1.</description>
    </item>
    
    <item>
      <title>Code Performance Analysis With Assembly &amp; C: Part 1</title>
      <link>https://jarrocha.github.io/post/2018-11-18-performance-analysis-i/</link>
      <pubDate>Fri, 19 Feb 2016 12:38:59 -0700</pubDate>
      
      <guid>https://jarrocha.github.io/post/2018-11-18-performance-analysis-i/</guid>
      <description>These blog series belong to some old notes that I have and thought that could be useful to redo. It is always good to refresh material and what a better way than to write about it.
These series will consists of presenting an algorithm in C that will iteratively be re-coded for better performance. Assembly code will be shown so as to show what&amp;rsquo;s going on at the instruction level, gprof, valgrind, and perf will be used to assess quantitavely our coding efforts.</description>
    </item>
    
  </channel>
</rss>